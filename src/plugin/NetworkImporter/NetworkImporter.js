/*globals define*/
/*jshint node:true, browser:true*/

/**
* Generated by PluginGenerator from webgme on Sat Aug 01 2015 20:03:52 GMT-0500 (CDT).
*/

define([
    'plugin/PluginConfig',
    'plugin/PluginBase',
    'plugin/NetworkImporter/NetworkImporter/meta'
], function (PluginConfig, PluginBase, MetaTypes) {
    'use strict';

    /**
    * Initializes a new instance of NetworkImporter.
    * @class
    * @augments {PluginBase}
    * @classdesc This class represents the plugin NetworkImporter.
    * @constructor
    */
    var NetworkImporter = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.metaTypes = MetaTypes;
    };

    // Prototypal inheritance from PluginBase.
    NetworkImporter.prototype = Object.create(PluginBase.prototype);
    NetworkImporter.prototype.constructor = NetworkImporter;

    NetworkImporter.prototype.getConfigStructure = function() {
        return [
            {
                'name': 'prototxt',
                'displayName': 'Caffe Network Prototxt',
                'description': '',
                'value': '',
                'valueType': 'asset',
                'readOnly': false
            }
        ];
    };

    /**
    * Gets the name of the NetworkImporter.
    * @returns {string} The name of the plugin.
    * @public
    */
    NetworkImporter.prototype.getName = function () {
        return 'Network Importer';
    };

    /**
    * Gets the semantic version (semver.org) of the NetworkImporter.
    * @returns {string} The version of the plugin.
    * @public
    */
    NetworkImporter.prototype.getVersion = function () {
        return '0.1.0';
    };

    /**
    * Main function for the plugin to execute. This will perform the execution.
    * Notes:
    * - Always log with the provided logger.[error,warning,info,debug].
    * - Do NOT put any user interaction logic UI, etc. inside this method.
    * - callback always has to be called even if error happened.
    *
    * @param {function(string, plugin.PluginResult)} callback - the result callback
    */
    NetworkImporter.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this;
        self.updateMETA(self.metaTypes);
        // TODO: Get the text from the config
        var currentConfig = self.getCurrentConfig(),
            prototxtHash = currentConfig.prototxt;

        // Parse the layers from the Caffe prototxt file
        self.blobClient.getObject(prototxtHash, function(err, arrayBuffer) {
            var prototxt = String.fromCharCode.apply(null, new Uint8Array(arrayBuffer)),
                nameRegex,
                name = 'Caffe_'+new Date(),
                regexResult,
                layers;

            nameRegex = /name:\s+"(\w+)"/;
            regexResult = nameRegex.exec(prototxt);
            if (regexResult !== null) {
                name = regexResult[1];
            }

            layers = NetworkImporter.parseLayersFromPrototxt(prototxt);

            // TODO: Create a model from the layers
            // TODO: How do you create nodes again?
            // FIXME: Do this in one transaction
            self.createCnnModel(name, layers);

            // Save
            self.result.setSuccess(true);
            self.save('added obj', function (err) {
                callback(null, self.result);
            });
        });

    };

    /**
     * Parse Caffe's prototxt and create the CNN layers
     *
     * @param {String} prototxt
     * @return {Layers[]}
     */
    NetworkImporter.parseLayersFromPrototxt = function(prototxt) {
        var layers;

        // Convert to nodes
        layers = prototxt.split("layer");
        layers.shift();  // Remove any content before the first layer (ie, name)
        return layers.map(NetworkImporter.parseLayer);
    };

    NetworkImporter.parseLayer = function(text) {
        var cleanedText = text

            // Remove sub params
            .replace(/(\w+)\s*{/g, function(a,b) {
                return '"'+b+'": {';
            })

            // Put quotes around the keys and maybe the values
            .replace(/(\w+)\s*:/g, function(a,b) {
                return '"'+b+'":';
            })
            // ... and maybe the values
            .replace(/:\s*(\w+)/g, function(a,b) {
                try {
                    JSON.parse(b); // Check if it is valid JS
                    return a;
                } catch (e) {
                    return ': "'+b+'"';
                }
            })

            // Add commas to the end of the attributes
            .replace(/("\w+"\s*:\s*["\w\d\.]+)/g, function(a,b) {
                return b+',';
            })
            .replace(/}/g, '},')
            // Remove extra commas
            .replace(/,\s*}/g, '}');

        // Remove the last comma
        var i = cleanedText.lastIndexOf(',');
        var layer = JSON.parse(cleanedText.substring(0, i));

        // Flatten the layer
        return NetworkImporter.flattenWithPrefix('', layer);
    };

    NetworkImporter.flattenWithPrefix = function(prefix, object) {
        var ids = Object.keys(object),
            flatObject = {};

        for (var i = ids.length; i--;) {
            if (typeof object[ids[i]] !== 'object') {
                flatObject[prefix+ids[i]] = object[ids[i]];
            } else {
                _.extend(flatObject, 
                    NetworkImporter.flattenWithPrefix(prefix+ids[i]+'_' ,object[ids[i]]));
            }
        }

        return flatObject;
    };

    NetworkImporter.prototype.createCnnModel = function(name, layers) {
        //this.core.createNode({parent: , base: });
        //this.core.setRegistry(node, 'position', {x: x, y: y});
        // TODO
    };

    return NetworkImporter;
});
